// SPDX-License-Identifier: MIT
pragma solidity 0.8.18;

contract MyToken {

    // Public variables to store the details about the coin
    string public n; // Token Name
    string public s; // Token Abbreviation
    uint256 public t; // Total Supply

    // Mapping of addresses to balances
    mapping(address => uint256) public balances;

    // Constructor to initialize the token name, symbol, and initial supply
    constructor(string memory _name, string memory _symbol, uint256 _initialSupply) {
        require(bytes(_name).length > 0, "Token name cannot be empty");
        require(bytes(_symbol).length > 0, "Token symbol cannot be empty");
        require(_initialSupply > 0, "Initial supply must be greater than zero");

        n = _name;
        s = _symbol;
        t = _initialSupply;
        balances[msg.sender] = _initialSupply; // Assign the entire initial supply to the contract deployer

        assert(t == balances[msg.sender]); // Assert that the total supply matches the deployer's balance
    }

    // Mint function to increase the total supply and balance of the specified address
    function mint(address _to, uint256 _value) public {
        require(_to != address(0), "Cannot mint to the zero address");
        require(_value > 0, "Mint value must be greater than zero");

        t += _value;
        balances[_to] += _value;

        assert(balances[_to] >= _value); // Assert that the balance of the recipient is correct
    }

    // Burn function to decrease the total supply and balance of the specified address
    function burn(address _from, uint256 _value) public {
        require(_from != address(0), "Cannot burn from the zero address");
        require(balances[_from] >= _value, "Insufficient balance to burn");
        require(_value > 0, "Burn value must be greater than zero");

        t -= _value;
        balances[_from] -= _value;

        assert(balances[_from] >= 0); // Assert that the balance does not go negative
    }

    // Function to check the balance of a specific address
    function balanceOf(address _owner) public view returns (uint256) {
        require(_owner != address(0), "Address cannot be the zero address");
        return balances[_owner];
    }

    // Function to demonstrate the use of require
    function demoRequire(bool _condition) public pure {
        require(_condition, "Require condition failed");
    }

    // Function to demonstrate the use of assert
    function demoAssert(uint256 _value) public pure {
        uint256 testValue = _value * 2;
        assert(testValue / 2 == _value); // Assert that the test value is correctly calculated
    }

    // Function to demonstrate the use of revert
    function demoRevert(bool _condition) public pure {
        if (_condition) {
            revert("Condition was true, triggering revert");
        }
    }
}
